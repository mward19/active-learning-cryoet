# import torch
from torch.utils.data import Dataset
import numpy as np
from tqdm.auto import tqdm

import json
import os
import re

class SubtomogramPointDataset(Dataset):
    """
    Loads subtomograms and any associated points as generated by
    dataset_creation.py.

    If bool_mode is on, __getitem__ returns the label as true if the tile
    contains at least one point, false if zero points. If bool_mode is off,
    returns the list of points in the tile.
    """
    def __init__(self, base_dir, bool_mode=True, max_tiles=None):
        self.base_dir = base_dir
        self.bool_mode = bool_mode

        self.tomo_dir_regex = re.compile(r'^tomo-(\d+)$')
        self.all_tiles_dir_regex = re.compile(r'^tiles-overlapped$')
        self.tile_dir_regex = re.compile(r'^tile-(\d+)-(\d+)-(\d+)$')
        self.points_regex = re.compile(r'^points\.json$')

        # TODO: add augmentations

        # Get all subtomogram paths
        self.samples = []
        self.positive_indices = []
        self.negative_indices = []

        dir_list = list(os.scandir(base_dir))

        tile_idx = 0
        for tomo in tqdm(dir_list, desc='Parsing directories'):
            if not tomo.is_dir():
                continue
            if not self.tomo_dir_regex.fullmatch(tomo.name):
                continue

            tiles_root = os.path.join(tomo.path, "tiles-overlapped")
            if not os.path.isdir(tiles_root):
                continue

            tiles_list = list(os.scandir(tiles_root))
            for tile in tqdm(tiles_list, desc='Collecting tiles', leave=False):
                if not tile.is_dir():
                    continue
                if not self.tile_dir_regex.fullmatch(tile.name):
                    continue

                root = tile.path
                tile_file = os.path.join(root, "tile.npy")

                pts_file = None
                for f in os.scandir(root):
                    if f.is_file() and self.points_regex.fullmatch(f.name):
                        pts_file = f.path
                        break

                if pts_file:
                    self.positive_indices.append(tile_idx)
                    with open(pts_file) as fp:
                        raw = json.load(fp)
                        points = [tuple(p) for p in raw]
                else:
                    self.negative_indices.append(tile_idx)
                    points = []

                self.samples.append((tile_file, points))
                tile_idx += 1
                if max_tiles is not None and tile_idx > max_tiles:
                    return


    def __len__(self):
        return len(self.samples)
    
    def num_positive_samples(self):
        return len(self.positive_indices)
    def num_negative_samples(self):
        return len(self.negative_indices)
    
    def get_positive_sample(self, idx):
        return self.__getitem__(self.positive_indices[idx])
    def get_negative_sample(self, idx):
        return self.__getitem__(self.negative_indices[idx])
        
    def __getitem__(self, idx):
        tile_file, points = self.samples[idx]
        tile = np.load(tile_file)
        if self.bool_mode:
            return tile, len(points) > 0
        else:
            return tile, points


if __name__ == '__main__':
    def clip_percentile(arr):
        lo, hi = np.percentile(arr, [2, 98])
        return np.clip(arr, lo, hi)
    spd = SubtomogramPointDataset(r'/home/mward19/nobackup/autodelete/fm-data-2', bool_mode=False, max_tiles=1000)
    from matplotlib import pyplot as plt
    tile, points = spd.get_positive_sample(7)
    plt.imshow(clip_percentile(tile[points[0][0]]), cmap='gray')
    plt.title(points)
    plt.savefig('temp.png')